


import React, { useEffect, useRef, useState } from 'react';
import p5 from 'p5';

const P5PenTest = () => {
  const sketchRef = useRef();
  const undoRef = useRef();
  const [showLayer1, setShowLayer1] = useState(true);
  const [showLayer2, setShowLayer2] = useState(true);
  const showLayer1Ref = useRef(showLayer1);
  const showLayer2Ref = useRef(showLayer2);
  const [activeLayer, setActiveLayer] = useState('layer1');
  const activeLayerRef = useRef(activeLayer);
  const layer1Ref = useRef();
  const layer2Ref = useRef();
  const [isDrawing, setIsDrawing] = useState(false);
  const isDrawingRef = useRef(isDrawing);
  const imageInputRef = useRef(null);
  const img = useRef(null);
  const p5InstanceRef = useRef();

  const [shouldDraw, setShouldDraw] = useState(false);
  const shouldDrawRef = useRef(shouldDraw);
  useEffect(() => {
    shouldDrawRef.current = shouldDraw;
  }, [shouldDraw]);


    // 描画データを保存するための状態
  // const [drawingData, setDrawingData] = useState({});
  const drawingDataRef = useRef();

  // useEffect(() => {
  //   drawingDataRef.current = drawingData;
  // }, [drawingData]);

  const handleImageChange = (e) => {
    if (e.target.files.length) {
      const file = e.target.files[0];
      const url = URL.createObjectURL(file);
      // p5のloadImageを使用して画像を読み込む
      new p5().loadImage(url, (loadedImage) => {
        img.current = loadedImage;
        // setShouldDraw(true); // 画像が読み込まれたら描画フラグを立てる
      });
      //同じ画像を再びセットできるようにする(ブラウザの仕様に引っかからないようにする)
      e.target.value = '';
    }
  };


  useEffect(() => {
    isDrawingRef.current = isDrawing;
  }, [isDrawing]);

  // コンポーネントの初期化部分
  useEffect(() => {
    // ExtendedUndoインスタンスの初期化
    undoRef.current = new ExtendedUndo(30);
  }, []);

  useEffect(() => {
    showLayer1Ref.current = showLayer1;
  }, [showLayer1]);

  useEffect(() => {
    showLayer2Ref.current = showLayer2;
  }, [showLayer2]);

  useEffect(() => {
    activeLayerRef.current = activeLayer;
  }, [activeLayer]);

  // mac用のcommand + Zをきかせるためのもの
  useEffect(() => {
    // キーダウンイベントを処理する関数
    const handleKeyDown = (event) => {
      const isMeta = event.metaKey; // Commandキー（Mac）またはWindowsキー（Windows）
      const isZ = event.key === 'z' || event.key === 'Z';
      const isShift = event.shiftKey;
  
      if (isMeta && isZ) {
        if (isShift) {
          // Command + Shift + Z (リドゥ)
          handleRedo();
        } else {
          // Command + Z (アンドゥ)
          handleUndo();
        }
        event.preventDefault(); // ブラウザのデフォルトの挙動を抑制
      }
    };
  
    // イベントリスナーを登録
    window.addEventListener('keydown', handleKeyDown);
  
    // コンポーネントのクリーンアップ時にイベントリスナーを削除
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, []); // 依存配列が空なので、コンポーネントのマウント時にのみ設定される
  

  useEffect(() => {
    const sketch = (p) => { 

      p.setup = () => {
        p.createCanvas(400, 400);
        p.background(123);

        layer1Ref.current = p.createGraphics(400, 400);
        layer2Ref.current = p.createGraphics(400, 400);

        // 初期状態のキャプチャ
        undoRef.current.capture([layer1Ref.current, layer2Ref.current]);

        // setDrawingData({
        //   shapes: [], // 初期状態として空の図形リスト
        // });
      };

      p.draw = () => {
        p.background(220);

        if (p.mouseIsPressed) {
          if (activeLayerRef.current === 'layer1' && showLayer1Ref.current) {
            layer1Ref.current.stroke(255, 0, 0);
            layer1Ref.current.strokeWeight(10);
            layer1Ref.current.line(p.pmouseX, p.pmouseY, p.mouseX, p.mouseY);
          } else if (activeLayerRef.current === 'layer2' && showLayer2Ref.current) {
            layer2Ref.current.stroke(0, 0, 255);
            layer2Ref.current.strokeWeight(10);
            layer2Ref.current.line(p.pmouseX, p.pmouseY, p.mouseX, p.mouseY);
          }
        };

        p.mousePressed = () => {
          if (img.current) {
            if (activeLayerRef.current === 'layer1' && showLayer1Ref.current) {
              layer1Ref.current.image(img.current, p.mouseX, p.mouseY);
              p.image(layer1Ref.current, 0, 0);
              img.current = null; 
            } else if (activeLayerRef.current === 'layer2' && showLayer2Ref.current) {
              layer2Ref.current.image(img.current, p.mouseX, p.mouseY);
              p.image(layer2Ref.current, 0, 0);
              img.current = null; 
            }
          }
          // マウスの位置がcanvasの範囲内にあるかチェック
          if (p.mouseX > 0 && p.mouseX < p.width && p.mouseY > 0 && p.mouseY < p.height) {
             // マウスがcanvas内で押された場合にのみtrueに設定
            setIsDrawing(true);
          }
        };

        // レイヤーの描画
        if (showLayer1Ref.current) {
          p.image(layer1Ref.current, 0, 0);
        }
        if (showLayer2Ref.current) {
          p.image(layer2Ref.current, 0, 0);
        }
      };

      p.mouseReleased = () => {
        if (isDrawingRef.current) {
        undoRef.current.capture([layer1Ref.current, layer2Ref.current]);
        setIsDrawing(false);
        }
        //console.log("履歴インデックス:", [layer1Ref.current, layer2Ref.current]);
        //console.log(isDrawingRef.current);
      };

      p.keyPressed = () => {
        // macOSのCommandキーまたはWindows/LinuxのCtrlキーをサポート
        const isUndo = (p.keyIsDown(90) && (p.keyIsDown(p.CONTROL) || p.keyIsDown(p.META))); // Z key
        const isRedo = (p.keyIsDown(90) && (p.keyIsDown(p.CONTROL) || p.keyIsDown(p.META)) && p.keyIsDown(p.SHIFT)); // Z key + Shift
      
        if (isUndo) {
          if (!p.keyIsDown(p.SHIFT)) { // Command + Z (アンドゥ)
            handleUndo();
          }
        } else if (isRedo) {
          handleRedo(); // Command + Shift + Z (リドゥ)
        }
      };

      p.mouseClicked = () => {
        if (shouldDrawRef.current) {
        p.saveCanvas('myCanvas', 'png');
        setShouldDraw(false)
        }
      }
      
      p5InstanceRef.current = p;
      // drawingDataRef.current = p;

    };

    const myp5 = new p5(sketch, sketchRef.current);


    return () => {
      myp5.remove();
    };
  }, []);

  useEffect(() => {
    document.oncontextmenu = () => false;
    return () => {
      document.oncontextmenu = null;
    };
  }, []);

  // キャンバスのデータをサーバーに送信する関数
  const handleSaveToServer = () => {
    if (p5InstanceRef.current) {
      const dataURL = p5InstanceRef.current.canvas.toDataURL('image/png');
      //console.log(dataURL);
      // fetch('YOUR_SERVER_ENDPOINT', {
      //   method: 'POST',
      //   headers: {
      //     'Content-Type': 'application/json',
      //   },
      //   body: JSON.stringify({ image: dataURL }),
      // })
      // .then(response => response.json())
      // .then(data => console.log('Success:', data))
      // .catch((error) => {
      //   console.error('Error:', error);
      // });
    }
  };
  // const handleSaveToServer = () => {
  //   const dataURL = sketchRef.current.getCanvasDataURL();
  //   console.log(dataURL);
    // fetch('YOUR_SERVER_ENDPOINT', { // サーバーのエンドポイントに置き換えてください
    //   method: 'POST',
    //   headers: {
    //     'Content-Type': 'application/json',
    //   },
    //   body: JSON.stringify({ image: dataURL }),
    // })
    // .then(response => response.json())
    // .then(data => console.log('Success:', data))
    // .catch((error) => {
    //   console.error('Error:', error);
    // });
  // };

  // const handleSaveProgress = () => {
  //   if (drawingDataRef.current) {
  //     const jsonData = JSON.stringify(drawingDataRef.current);
  //     console.log(jsonData);
  //   }
  // }

  // キャンバスのデータをサーバーに送信する関数
  const savePc = () => {
    if (p5InstanceRef.current) {
      setShouldDraw(true);
    }
  };


  return (
    <div>
      <div ref={sketchRef}></div>
      <button onClick={handleSaveToServer}>サーバーに保存</button>
      <button onClick={savePc}>pcに保存</button>
      {/* <button onClick={handleSaveProgress}>jsonで保存</button> */}
      <label>
        <input
          type="checkbox"
          checked={showLayer1}
          onChange={(e) => setShowLayer1(e.target.checked)}
        /> Show Layer 1
      </label>
      <label>
        <input
          type="checkbox"
          checked={showLayer2}
          onChange={(e) => setShowLayer2(e.target.checked)}
        /> Show Layer 2
      </label>
      <button onClick={() => setActiveLayer('layer1')}>Select Layer 1</button>
      <button onClick={() => setActiveLayer('layer2')}>Select Layer 2</button>
          {/* 戻るボタン */}
    <button onClick={handleUndo}>戻る</button>
    {/* 進むボタン */}
    <button onClick={handleRedo}>進む</button>
    <input
        type="file"
        id="imageInputP5"
        accept="image/*"
        style={{ display: 'none' }}
        ref={imageInputRef}
        onChange={handleImageChange}
      />
      <label htmlFor="imageInputP5" className="pain-button">
        <i className="bi bi-image"></i>
      </label>
    </div>
  );

  // アンドゥ/リドゥ操作の処理
  function handleUndo() {
    const historyState = undoRef.current.undo();
    if (historyState) {
      applyHistoryState(historyState);
    }
  }

  function handleRedo() {
    const historyState = undoRef.current.redo();
    if (historyState) {
      applyHistoryState(historyState);
    }
  }

  function applyHistoryState(historyState) {
    if (!historyState) return; // 履歴の状態がnullの場合は何もしない
  
    // 履歴の状態（レイヤーの画像データの配列）を各レイヤーに適用
    const [layer1State, layer2State] = historyState;
    
    layer1Ref.current.clear();
    layer1Ref.current.image(layer1State, 0, 0);
  
    layer2Ref.current.clear();
    layer2Ref.current.image(layer2State, 0, 0);
  }
};


class ExtendedUndo {
  constructor(maxHistoryCount) {
    this.maxHistoryCount = maxHistoryCount;
    this.history = [];
    this.current = -1; // 最初は履歴がないため
  }

  capture(layers) {
    const state = layers.map(layer => layer.get()); // すべてのレイヤーの状態をキャプチャ
    // 現在位置より後の履歴を削除
    this.history = this.history.slice(0, this.current + 1);
    this.history.push(state);
    this.current++;

    // 履歴の最大数を超えた場合、古い履歴を削除
    if (this.history.length > this.maxHistoryCount) {
      this.history.shift();
      this.current--;
    }
  }

  undo() {
    if (this.current > 0) {
      this.current--;
      return this.history[this.current]; // 履歴の状態を返す
    }
    return null;
  }

  redo() {
    if (this.current < this.history.length - 1) {
      this.current++;
      return this.history[this.current]; // 履歴の状態を返す
    }
    return null;
  }
}

export default P5PenTest;

